package chapter5.section4

/**
 * 为以下应用写出Java的正则表达式
 * a.电话号码，例如 (609) 555-1234
 * b.社会保险号，例如 123-45-6789
 * c.日期，例如 December 31, 1999
 * d.形如 a.b.c.d的IP地址，其中每个字符都表示着一个可能是1位、2位或者3位的数字，例如 196.26.155.241
 * e.车牌号，前4个字符位数字，最后2个字符为大写字母
 *
 * 解：NFA的实现不支持重复指定次数，所以这里只给出正则表达式，而无法直接测试
 * 可以在这个网站测试：http://www.bejson.com/othertools/regex/
 * 需要注意，标准的正则表达式重复1~3次使用{1,3}而不是{1-3}，
 * 需要手动在正则表达式开头加'^'字符，结尾加'$'字符，用来限定必须完全匹配
 */
fun main() {
    // 电话号码
    val regex1 = "\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}"
    // 社会保险号
    val regex2 = "[0-9]{3}-[0-9]{2}-[0-9]{4}"
    // 日期 日期范围为1-31，年份范围只限定4位数
    val regex3 = "(January|February|March|April|May|June|July|August|September|October|November|December) ([1-9]|[12][0-9]|3[01]), [0-9]{4}"
    // IP地址 IP地址每个元素的范围为0~255，不含前置0，如05显示为5，每个元素都要匹配0~9、10~99、100~199、200~249、250~255中的任意一个
    val regex4 = "(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
    // 车牌号
    val regex5 = "[0-9]{4}[A-Z]{2}"
}